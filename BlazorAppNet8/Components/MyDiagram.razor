@page "/my-diagram"
@using Blazor.Diagrams.Components
@using Blazor.Diagrams
@using Blazor.Diagrams.Core.PathGenerators
@using Blazor.Diagrams.Core.Routers
@using Blazor.Diagrams.Options
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Positions
@using Blazor.Diagrams.Core.Geometry
@using BlazorAppNet8.Classes
@using BlazorAppNet8.Components.MyNodes
@using BlazorAppNet8.Components.MyNodes.Interfaces;

@namespace BlazorAppNet8.Components.MyNodes

<div class="diagram-container">
    <CascadingValue Value="this" IsFixed="true">
        <CascadingValue Value="Diagram" IsFixed="true">
            <DiagramCanvas></DiagramCanvas>
        </CascadingValue>
    </CascadingValue>
</div>

@code {
    private BlazorDiagram Diagram { get; set; } = null!;
    [Parameter]
    public List<INode<IHierarchyItem>> hierarchyItems { get; set; } = new();

    protected override void OnInitialized()
    {
        InitializeDiagram();
    }

    private void InitializeDiagram()
    {
        var options = new BlazorDiagramOptions
        {
            AllowMultiSelection = false,
            Zoom = { Enabled = false, },
            Links = { DefaultRouter = new NormalRouter(), DefaultPathGenerator = new StraightPathGenerator() },
        };

        Diagram = new BlazorDiagram(options);
        Diagram.RegisterComponent<DepartmentNode, DepartmentWidget>();

        UpdateDiagram();
    }

    private void UpdateDiagram()
    {
        Diagram.Nodes.Clear();
        Diagram.Links.Clear();

        var rootNodes = hierarchyItems.Where(d => !d.ParentId.HasValue).ToList();
        foreach (var root in rootNodes)
        {
            AddNodeWithChildren(root);
        }

        RecalculateNodePositions();
    }

    private void AddNodeWithChildren(IHierarchyItem hierarchyItem)
    {
        var node = Diagram.Nodes.OfType<INode<IHierarchyItem>>().FirstOrDefault(n => n.Item.Id == hierarchyItem.Id);
        if (node == null)
        {
            var position = NodePositionCalculator.CalculatePositions(hierarchyItems)[hierarchyItem.Id];
            node = new INode<IHierarchyItem>(position) { Item = hierarchyItem };
            Diagram.Nodes.Add(node);
        }

        if (node.IsExpanded)
        {
            var children = hierarchyItems.Where(d => d.ParentId == hierarchyItem.Id).ToList();
            foreach (var child in children)
            {
                AddNodeWithChildren(child);
                AddLinkBetweenNodes(node, Diagram.Nodes.OfType<DepartmentNode>().First(n => n.Item.Id == child.Id));
            }
        }

        node.OnToggleChildren = () =>
        {
            node.IsExpanded = !node.IsExpanded;
            if (node.IsExpanded)
            {
                ExpandNode(node);
            }
            else
            {
                CollapseNode(node);
            }
            RecalculateNodePositions();
        };
    }

    private void ExpandNode(INode<IHierarchyItem> node)
    {
        var children = hierarchyItems.Where(d => d.ParentId == node.Item.Id).ToList();
        foreach (var child in children)
        {
            AddNodeWithChildren(child);
            AddLinkBetweenNodes(node, Diagram.Nodes.OfType<DepartmentNode>().First(n => n.Item.Id == child.Id));
        }
    }

    private void CollapseNode(INode<IHierarchyItem> node)
    {
        var childNodes = Diagram.Nodes.Where(n => n is DepartmentNode dn && dn.Item.ParentId == node.Item.Id).ToList();
        foreach (var childNode in childNodes)
        {
            RemoveNodeAndLinks(childNode);
        }
    }

    private void RemoveNodeAndLinks(NodeModel node)
    {
        var linksToRemove = Diagram.Links.Where(l =>
            (l.Source is SinglePortAnchor sourceAnchor && sourceAnchor.Port.Parent == node) ||
            (l.Target is SinglePortAnchor targetAnchor && targetAnchor.Port.Parent == node)).ToList();

        foreach (var link in linksToRemove)
        {
            Diagram.Links.Remove(link);
        }

        Diagram.Nodes.Remove(node);

        if (node is DepartmentNode departmentNode)
        {
            var grandChildNodes = Diagram.Nodes.Where(n => n is DepartmentNode dn && dn.Item.ParentId == departmentNode.Item.Id).ToList();
            foreach (var grandChildNode in grandChildNodes)
            {
                RemoveNodeAndLinks(grandChildNode);
            }
        }
    }

    private void AddLinkBetweenNodes(DepartmentNode parentNode, DepartmentNode childNode)
    {
        var parentPort = parentNode.AddPort(PortAlignment.Bottom);
        var childPort = childNode.AddPort(PortAlignment.Top);

        var sourceAnchor = new DynamicAnchor(parentNode, new[]
            {
            new BoundsBasedPositionProvider(0.5, 0), // Center top
            new BoundsBasedPositionProvider(0.5, 1), // Center bottom
        });

        var targetAnchor = new DynamicAnchor(childNode, new[]
            {
            new BoundsBasedPositionProvider(0.5, 0), // Center top
            new BoundsBasedPositionProvider(0.5, 1), // Center bottom
        });
        // Diagram.Links.Add(new LinkModel(daSourceAnchor, someTargetAnchor));


        var link = new LinkModel(sourceAnchor, targetAnchor) { 
            Router = new OrthogonalRouter(), 
            TargetMarker = LinkMarker.Arrow 
        };
        Diagram.Links.Add(link);
    }

    private void RecalculateNodePositions()
    {
        var visibleNodes = Diagram.Nodes.OfType<INode<IHierarchyItem>>().ToList();
        IHierarchyItem[] hierarchyItems = visibleNodes
            .Select(node => node.Item)
            .Cast<IHierarchyItem>()
            .ToArray();
        var positions = NodePositionCalculator.CalculatePositions(hierarchyItems);

        foreach (var node in visibleNodes)
        {
            if (positions.TryGetValue(node.Item.Id, out var newPosition))
            {
                node.SetPosition(newPosition.X, newPosition.Y);
            }
        }

        Diagram.Refresh();
    }

    public void AddChildDepartment(int parentId)
    {
        var newDepartment = new Department
        {
            Id = hierarchyItems.Max(d => d.Id) + 1,
            Name = $"Новое подразделение {hierarchyItems.Max(d => d.Id) + 1}",
            ParentId = parentId
        };

        hierarchyItems.Add(newDepartment);
            var parentNode = Diagram.Nodes.OfType<DepartmentNode>().FirstOrDefault(n => n.Item.Id == parentId);

        if (parentNode != null)
        {
            if (!parentNode.IsExpanded)
            {
                parentNode.IsExpanded = true;
                ExpandNode(parentNode);
            }
            AddNodeWithChildren(newDepartment);
                AddLinkBetweenNodes(parentNode, Diagram.Nodes.OfType<DepartmentNode>().First(n => n.Item.Id == newDepartment.Id));
            RecalculateNodePositions();
        }
    }

    public void DeleteDepartment(int nodeId)
    {
        var nodeToRemove = hierarchyItems.FirstOrDefault(d => d.Id == nodeId);
        var node = Diagram.Nodes.OfType<INode<IHierarchyItem>>().FirstOrDefault(n => n.Item.Id == nodeId);

        if (nodeToRemove != null)
        {
            hierarchyItems.Remove(nodeToRemove);
            RemoveNodeAndLinks(node);
        }
    }
}

<style>
    .diagram-container {
        width: 100%;
        height: 850px;
        border: solid 1px black;
        border-radius: 10px;
    }
</style>